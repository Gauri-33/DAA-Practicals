#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <float.h>
#include <math.h>
#define V 8
#define E 12
 
struct Edge {
    int src, dest,cost;
};

double euclidean(double lat1, double lon1, double lat2, double lon2) {
    return sqrt((lat2 - lat1) * (lat2 - lat1) + (lon2 - lon1) * (lon2 - lon1));
}

void BellmanFord(struct Edge edges[], int src){
   float dist[V];
    for (int i = 0; i < V; i++)
        dist[i] = FLT_MAX;
    dist[src] = 0;
    for (int i = 1; i <= V - 1; i++) {
        for (int j = 0; j < E; j++) {
            int u = edges[j].src;
            int v = edges[j].dest;
            float c = edges[j].cost;
            if (dist[u] != FLT_MAX && dist[u] + c < dist[v]){
                dist[v] = dist[u] + c;
            }
            else if (dist[u] != FLT_MAX && dist[u] + c < dist[v]) {
            printf("Negative weight cycle detected\n");
            return;
        }
        }
    }
    printf("Shortest distances from source %d:\n", src);
    for (int i = 0; i < V; i++){
        printf("To vertex %d: %.2f\n", i, dist[i]);
    }
}
int main(){
    struct Edge edges[E] = {
        {0, 1, 6},
        {0, 2, 7},
        {1, 5, 8},
        {1, 3, 5},
        {1, 4, -4},
        {2, 3, -3},
        {2, 6, 9},
        {3, 1, -2},
        {5, 1, 2},
        {4, 0, 5},
        {3, 1, -4},
        {5, 7, 5}
    };
     int source = 0;
    BellmanFord(edges, source);
}
